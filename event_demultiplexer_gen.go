package disgord

// Warning: This file has been automatically generated by generate/events/main.go
// DO NOT EDIT! This file is overwritten at "go generate", instead adapt events.go
// and event/events.go and run go generate

import (
	"context"
	"errors"
	"fmt"
	"sync"
)

// HandlerCtrl used when inserting a handler to dictate whether or not the handler(s) should
// still be kept in the handlers list..
type HandlerCtrl interface {
	OnInsert(Session) error
	OnRemove(Session) error

	// IsDead does not need to be locked as the demultiplexer access it synchronously.
	IsDead() bool

	// Update For every time Update is called, it's internal trackers must be updated.
	// you should assume that .Update() means the handler was used.
	Update()
}

type eternalHandlersCtrl struct {
	Ctrl
}

var _ HandlerCtrl = (*eternalHandlersCtrl)(nil)

func (c *eternalHandlersCtrl) Update()      {}
func (c *eternalHandlersCtrl) IsDead() bool { return false }

// reused by handlers that have no ctrl defined
var eternalCtrl = &eternalHandlersCtrl{}

type Handler = interface{}
type Middleware = func(interface{}) interface{}

// handlerSpec (handler specification) holds the details for executing the handler
type handlerSpec struct {
	sync.RWMutex
	middlewares []Middleware
	handlers    []Handler
	ctrl        HandlerCtrl
}

func (hs *handlerSpec) next() bool {
	hs.Lock()
	defer hs.Unlock()

	if hs.ctrl.IsDead() {
		return false
	}

	hs.ctrl.Update()
	return true
}

func (hs *handlerSpec) populate(inputs ...interface{}) (err error) {
	var i int

	// middlewares
	for ; i < len(inputs); i++ {
		if mdlw, ok := inputs[i].(Middleware); ok {
			hs.middlewares = append(hs.middlewares, mdlw)
		} else {
			break
		}
	}

	// handlers
	for ; i < len(inputs)-1; i++ {
		if handler, ok := inputs[i].(Handler); ok {
			hs.handlers = append(hs.handlers, handler)
		} else {
			break
		}
	}

	// check if last arg is a controller
	if i < len(inputs) {
		if ctrl, ok := inputs[i].(HandlerCtrl); ok {
			hs.ctrl = ctrl
			i++
		} else if handler, ok := inputs[i].(Handler); ok {
			hs.handlers = append(hs.handlers, handler)
			hs.ctrl = eternalCtrl
			i++
		}
	}

	if len(inputs) != i {
		format := "unable to add all handlers/middlewares (%d/%d). Are they in correct order? middlewares, then handlers"
		err = errors.New(fmt.Sprintf(format, i, len(inputs)))
	}

	return err
}

func (hs *handlerSpec) runMdlws(evt interface{}) interface{} {
	for i := range hs.middlewares {
		evt = hs.middlewares[i](evt) // note how the evt pointer is overwritten
		if evt == nil {
			break
		}
	}

	return evt
}

func (hs *handlerSpec) dispatch(evtName string, session Session, evt interface{}) {
	// ordering is important
	switch evtName {

	case EventChannelCreate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(ChannelCreateHandler); ok {
				cb(session, evt.(*ChannelCreate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: ChannelCreate")
			}
		}
	case EventChannelDelete:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(ChannelDeleteHandler); ok {
				cb(session, evt.(*ChannelDelete))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: ChannelDelete")
			}
		}
	case EventChannelPinsUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(ChannelPinsUpdateHandler); ok {
				cb(session, evt.(*ChannelPinsUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: ChannelPinsUpdate")
			}
		}
	case EventChannelUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(ChannelUpdateHandler); ok {
				cb(session, evt.(*ChannelUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: ChannelUpdate")
			}
		}
	case EventGuildBanAdd:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildBanAddHandler); ok {
				cb(session, evt.(*GuildBanAdd))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildBanAdd")
			}
		}
	case EventGuildBanRemove:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildBanRemoveHandler); ok {
				cb(session, evt.(*GuildBanRemove))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildBanRemove")
			}
		}
	case EventGuildCreate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildCreateHandler); ok {
				cb(session, evt.(*GuildCreate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildCreate")
			}
		}
	case EventGuildDelete:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildDeleteHandler); ok {
				cb(session, evt.(*GuildDelete))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildDelete")
			}
		}
	case EventGuildEmojisUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildEmojisUpdateHandler); ok {
				cb(session, evt.(*GuildEmojisUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildEmojisUpdate")
			}
		}
	case EventGuildIntegrationsUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildIntegrationsUpdateHandler); ok {
				cb(session, evt.(*GuildIntegrationsUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildIntegrationsUpdate")
			}
		}
	case EventGuildMemberAdd:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildMemberAddHandler); ok {
				cb(session, evt.(*GuildMemberAdd))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildMemberAdd")
			}
		}
	case EventGuildMemberRemove:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildMemberRemoveHandler); ok {
				cb(session, evt.(*GuildMemberRemove))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildMemberRemove")
			}
		}
	case EventGuildMemberUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildMemberUpdateHandler); ok {
				cb(session, evt.(*GuildMemberUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildMemberUpdate")
			}
		}
	case EventGuildMembersChunk:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildMembersChunkHandler); ok {
				cb(session, evt.(*GuildMembersChunk))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildMembersChunk")
			}
		}
	case EventGuildRoleCreate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildRoleCreateHandler); ok {
				cb(session, evt.(*GuildRoleCreate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildRoleCreate")
			}
		}
	case EventGuildRoleDelete:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildRoleDeleteHandler); ok {
				cb(session, evt.(*GuildRoleDelete))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildRoleDelete")
			}
		}
	case EventGuildRoleUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildRoleUpdateHandler); ok {
				cb(session, evt.(*GuildRoleUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildRoleUpdate")
			}
		}
	case EventGuildUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(GuildUpdateHandler); ok {
				cb(session, evt.(*GuildUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: GuildUpdate")
			}
		}
	case EventMessageCreate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(MessageCreateHandler); ok {
				cb(session, evt.(*MessageCreate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: MessageCreate")
			}
		}
	case EventMessageDelete:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(MessageDeleteHandler); ok {
				cb(session, evt.(*MessageDelete))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: MessageDelete")
			}
		}
	case EventMessageDeleteBulk:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(MessageDeleteBulkHandler); ok {
				cb(session, evt.(*MessageDeleteBulk))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: MessageDeleteBulk")
			}
		}
	case EventMessageReactionAdd:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(MessageReactionAddHandler); ok {
				cb(session, evt.(*MessageReactionAdd))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: MessageReactionAdd")
			}
		}
	case EventMessageReactionRemove:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(MessageReactionRemoveHandler); ok {
				cb(session, evt.(*MessageReactionRemove))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: MessageReactionRemove")
			}
		}
	case EventMessageReactionRemoveAll:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(MessageReactionRemoveAllHandler); ok {
				cb(session, evt.(*MessageReactionRemoveAll))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: MessageReactionRemoveAll")
			}
		}
	case EventMessageUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(MessageUpdateHandler); ok {
				cb(session, evt.(*MessageUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: MessageUpdate")
			}
		}
	case EventPresenceUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(PresenceUpdateHandler); ok {
				cb(session, evt.(*PresenceUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: PresenceUpdate")
			}
		}
	case EventPresencesReplace:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(PresencesReplaceHandler); ok {
				cb(session, evt.(*PresencesReplace))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: PresencesReplace")
			}
		}
	case EventReady:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(ReadyHandler); ok {
				cb(session, evt.(*Ready))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: Ready")
			}
		}
	case EventResumed:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(ResumedHandler); ok {
				cb(session, evt.(*Resumed))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: Resumed")
			}
		}
	case EventTypingStart:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(TypingStartHandler); ok {
				cb(session, evt.(*TypingStart))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: TypingStart")
			}
		}
	case EventUserUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(UserUpdateHandler); ok {
				cb(session, evt.(*UserUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: UserUpdate")
			}
		}
	case EventVoiceServerUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(VoiceServerUpdateHandler); ok {
				cb(session, evt.(*VoiceServerUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: VoiceServerUpdate")
			}
		}
	case EventVoiceStateUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(VoiceStateUpdateHandler); ok {
				cb(session, evt.(*VoiceStateUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: VoiceStateUpdate")
			}
		}
	case EventWebhooksUpdate:
		for _, handler := range hs.handlers {
			if cb, ok := handler.(WebhooksUpdateHandler); ok {
				cb(session, evt.(*WebhooksUpdate))
			} else if cb, ok := handler.(SimpleHandler); ok {
				cb(session)
			} else if cb, ok := handler.(SimplestHandler); ok {
				cb()
			} else {
				fmt.Println("ERROR! Incorrect handler type given for event: WebhooksUpdate")
			}
		}
	}
}

// NewDispatch construct a Dispatch object for reacting to web socket events
// from discord
func newEvtDemultiplexer(activateEventChannels bool, evtChanSize int) *evtDemultiplexer {
	dem := &evtDemultiplexer{
		activateEventChannels: activateEventChannels,
		handlers:              make(map[string][]*handlerSpec),
		shutdown:              make(chan struct{}),
	}

	if activateEventChannels {

		dem.channelCreateChan = make(chan *ChannelCreate, evtChanSize)
		dem.channelDeleteChan = make(chan *ChannelDelete, evtChanSize)
		dem.channelPinsUpdateChan = make(chan *ChannelPinsUpdate, evtChanSize)
		dem.channelUpdateChan = make(chan *ChannelUpdate, evtChanSize)
		dem.guildBanAddChan = make(chan *GuildBanAdd, evtChanSize)
		dem.guildBanRemoveChan = make(chan *GuildBanRemove, evtChanSize)
		dem.guildCreateChan = make(chan *GuildCreate, evtChanSize)
		dem.guildDeleteChan = make(chan *GuildDelete, evtChanSize)
		dem.guildEmojisUpdateChan = make(chan *GuildEmojisUpdate, evtChanSize)
		dem.guildIntegrationsUpdateChan = make(chan *GuildIntegrationsUpdate, evtChanSize)
		dem.guildMemberAddChan = make(chan *GuildMemberAdd, evtChanSize)
		dem.guildMemberRemoveChan = make(chan *GuildMemberRemove, evtChanSize)
		dem.guildMemberUpdateChan = make(chan *GuildMemberUpdate, evtChanSize)
		dem.guildMembersChunkChan = make(chan *GuildMembersChunk, evtChanSize)
		dem.guildRoleCreateChan = make(chan *GuildRoleCreate, evtChanSize)
		dem.guildRoleDeleteChan = make(chan *GuildRoleDelete, evtChanSize)
		dem.guildRoleUpdateChan = make(chan *GuildRoleUpdate, evtChanSize)
		dem.guildUpdateChan = make(chan *GuildUpdate, evtChanSize)
		dem.messageCreateChan = make(chan *MessageCreate, evtChanSize)
		dem.messageDeleteChan = make(chan *MessageDelete, evtChanSize)
		dem.messageDeleteBulkChan = make(chan *MessageDeleteBulk, evtChanSize)
		dem.messageReactionAddChan = make(chan *MessageReactionAdd, evtChanSize)
		dem.messageReactionRemoveChan = make(chan *MessageReactionRemove, evtChanSize)
		dem.messageReactionRemoveAllChan = make(chan *MessageReactionRemoveAll, evtChanSize)
		dem.messageUpdateChan = make(chan *MessageUpdate, evtChanSize)
		dem.presenceUpdateChan = make(chan *PresenceUpdate, evtChanSize)
		dem.presencesReplaceChan = make(chan *PresencesReplace, evtChanSize)
		dem.readyChan = make(chan *Ready, evtChanSize)
		dem.resumedChan = make(chan *Resumed, evtChanSize)
		dem.typingStartChan = make(chan *TypingStart, evtChanSize)
		dem.userUpdateChan = make(chan *UserUpdate, evtChanSize)
		dem.voiceServerUpdateChan = make(chan *VoiceServerUpdate, evtChanSize)
		dem.voiceStateUpdateChan = make(chan *VoiceStateUpdate, evtChanSize)
		dem.webhooksUpdateChan = make(chan *WebhooksUpdate, evtChanSize)
	}

	return dem
}

// evtDemultiplexer holds all the channels and internal state for all registered
// observers
type evtDemultiplexer struct {
	sync.RWMutex

	channelCreateChan            chan *ChannelCreate
	channelDeleteChan            chan *ChannelDelete
	channelPinsUpdateChan        chan *ChannelPinsUpdate
	channelUpdateChan            chan *ChannelUpdate
	guildBanAddChan              chan *GuildBanAdd
	guildBanRemoveChan           chan *GuildBanRemove
	guildCreateChan              chan *GuildCreate
	guildDeleteChan              chan *GuildDelete
	guildEmojisUpdateChan        chan *GuildEmojisUpdate
	guildIntegrationsUpdateChan  chan *GuildIntegrationsUpdate
	guildMemberAddChan           chan *GuildMemberAdd
	guildMemberRemoveChan        chan *GuildMemberRemove
	guildMemberUpdateChan        chan *GuildMemberUpdate
	guildMembersChunkChan        chan *GuildMembersChunk
	guildRoleCreateChan          chan *GuildRoleCreate
	guildRoleDeleteChan          chan *GuildRoleDelete
	guildRoleUpdateChan          chan *GuildRoleUpdate
	guildUpdateChan              chan *GuildUpdate
	messageCreateChan            chan *MessageCreate
	messageDeleteChan            chan *MessageDelete
	messageDeleteBulkChan        chan *MessageDeleteBulk
	messageReactionAddChan       chan *MessageReactionAdd
	messageReactionRemoveChan    chan *MessageReactionRemove
	messageReactionRemoveAllChan chan *MessageReactionRemoveAll
	messageUpdateChan            chan *MessageUpdate
	presenceUpdateChan           chan *PresenceUpdate
	presencesReplaceChan         chan *PresencesReplace
	readyChan                    chan *Ready
	resumedChan                  chan *Resumed
	typingStartChan              chan *TypingStart
	userUpdateChan               chan *UserUpdate
	voiceServerUpdateChan        chan *VoiceServerUpdate
	voiceStateUpdateChan         chan *VoiceStateUpdate
	webhooksUpdateChan           chan *WebhooksUpdate

	activateEventChannels bool

	handlers map[string][]*handlerSpec

	// use session to allow mocking the client instance later on
	session  Session
	shutdown chan struct{}
}

func (d *evtDemultiplexer) nrOfAliveHandlers() (counter int) {
	for k := range d.handlers {
		for i := range d.handlers[k] {
			if d.handlers[k][i].ctrl.IsDead() == false {
				counter++
			}
		}
	}

	return
}

// EventChan ... TODO
func (d *evtDemultiplexer) EventChan(evt string) (channel interface{}, err error) {
	if !d.activateEventChannels {
		return nil, errors.New("usage of event channels have not been activated. See disgord.Config")
	}

	switch evt {

	case EventChannelCreate:
		channel = d.ChannelCreate()
	case EventChannelDelete:
		channel = d.ChannelDelete()
	case EventChannelPinsUpdate:
		channel = d.ChannelPinsUpdate()
	case EventChannelUpdate:
		channel = d.ChannelUpdate()
	case EventGuildBanAdd:
		channel = d.GuildBanAdd()
	case EventGuildBanRemove:
		channel = d.GuildBanRemove()
	case EventGuildCreate:
		channel = d.GuildCreate()
	case EventGuildDelete:
		channel = d.GuildDelete()
	case EventGuildEmojisUpdate:
		channel = d.GuildEmojisUpdate()
	case EventGuildIntegrationsUpdate:
		channel = d.GuildIntegrationsUpdate()
	case EventGuildMemberAdd:
		channel = d.GuildMemberAdd()
	case EventGuildMemberRemove:
		channel = d.GuildMemberRemove()
	case EventGuildMemberUpdate:
		channel = d.GuildMemberUpdate()
	case EventGuildMembersChunk:
		channel = d.GuildMembersChunk()
	case EventGuildRoleCreate:
		channel = d.GuildRoleCreate()
	case EventGuildRoleDelete:
		channel = d.GuildRoleDelete()
	case EventGuildRoleUpdate:
		channel = d.GuildRoleUpdate()
	case EventGuildUpdate:
		channel = d.GuildUpdate()
	case EventMessageCreate:
		channel = d.MessageCreate()
	case EventMessageDelete:
		channel = d.MessageDelete()
	case EventMessageDeleteBulk:
		channel = d.MessageDeleteBulk()
	case EventMessageReactionAdd:
		channel = d.MessageReactionAdd()
	case EventMessageReactionRemove:
		channel = d.MessageReactionRemove()
	case EventMessageReactionRemoveAll:
		channel = d.MessageReactionRemoveAll()
	case EventMessageUpdate:
		channel = d.MessageUpdate()
	case EventPresenceUpdate:
		channel = d.PresenceUpdate()
	case EventPresencesReplace:
		channel = d.PresencesReplace()
	case EventReady:
		channel = d.Ready()
	case EventResumed:
		channel = d.Resumed()
	case EventTypingStart:
		channel = d.TypingStart()
	case EventUserUpdate:
		channel = d.UserUpdate()
	case EventVoiceServerUpdate:
		channel = d.VoiceServerUpdate()
	case EventVoiceStateUpdate:
		channel = d.VoiceStateUpdate()
	case EventWebhooksUpdate:
		channel = d.WebhooksUpdate()
	default:
		err = errors.New("no event channel exists for given event: " + evt)
	}

	return
}

func (d *evtDemultiplexer) triggerChan(ctx context.Context, evtName string, session Session, box interface{}) {
	if !d.activateEventChannels {
		return
	}

	switch evtName {

	case EventChannelCreate:
		d.channelCreateChan <- box.(*ChannelCreate)
	case EventChannelDelete:
		d.channelDeleteChan <- box.(*ChannelDelete)
	case EventChannelPinsUpdate:
		d.channelPinsUpdateChan <- box.(*ChannelPinsUpdate)
	case EventChannelUpdate:
		d.channelUpdateChan <- box.(*ChannelUpdate)
	case EventGuildBanAdd:
		d.guildBanAddChan <- box.(*GuildBanAdd)
	case EventGuildBanRemove:
		d.guildBanRemoveChan <- box.(*GuildBanRemove)
	case EventGuildCreate:
		d.guildCreateChan <- box.(*GuildCreate)
	case EventGuildDelete:
		d.guildDeleteChan <- box.(*GuildDelete)
	case EventGuildEmojisUpdate:
		d.guildEmojisUpdateChan <- box.(*GuildEmojisUpdate)
	case EventGuildIntegrationsUpdate:
		d.guildIntegrationsUpdateChan <- box.(*GuildIntegrationsUpdate)
	case EventGuildMemberAdd:
		d.guildMemberAddChan <- box.(*GuildMemberAdd)
	case EventGuildMemberRemove:
		d.guildMemberRemoveChan <- box.(*GuildMemberRemove)
	case EventGuildMemberUpdate:
		d.guildMemberUpdateChan <- box.(*GuildMemberUpdate)
	case EventGuildMembersChunk:
		d.guildMembersChunkChan <- box.(*GuildMembersChunk)
	case EventGuildRoleCreate:
		d.guildRoleCreateChan <- box.(*GuildRoleCreate)
	case EventGuildRoleDelete:
		d.guildRoleDeleteChan <- box.(*GuildRoleDelete)
	case EventGuildRoleUpdate:
		d.guildRoleUpdateChan <- box.(*GuildRoleUpdate)
	case EventGuildUpdate:
		d.guildUpdateChan <- box.(*GuildUpdate)
	case EventMessageCreate:
		d.messageCreateChan <- box.(*MessageCreate)
	case EventMessageDelete:
		d.messageDeleteChan <- box.(*MessageDelete)
	case EventMessageDeleteBulk:
		d.messageDeleteBulkChan <- box.(*MessageDeleteBulk)
	case EventMessageReactionAdd:
		d.messageReactionAddChan <- box.(*MessageReactionAdd)
	case EventMessageReactionRemove:
		d.messageReactionRemoveChan <- box.(*MessageReactionRemove)
	case EventMessageReactionRemoveAll:
		d.messageReactionRemoveAllChan <- box.(*MessageReactionRemoveAll)
	case EventMessageUpdate:
		d.messageUpdateChan <- box.(*MessageUpdate)
	case EventPresenceUpdate:
		d.presenceUpdateChan <- box.(*PresenceUpdate)
	case EventPresencesReplace:
		d.presencesReplaceChan <- box.(*PresencesReplace)
	case EventReady:
		d.readyChan <- box.(*Ready)
	case EventResumed:
		d.resumedChan <- box.(*Resumed)
	case EventTypingStart:
		d.typingStartChan <- box.(*TypingStart)
	case EventUserUpdate:
		d.userUpdateChan <- box.(*UserUpdate)
	case EventVoiceServerUpdate:
		d.voiceServerUpdateChan <- box.(*VoiceServerUpdate)
	case EventVoiceStateUpdate:
		d.voiceStateUpdateChan <- box.(*VoiceStateUpdate)
	case EventWebhooksUpdate:
		d.webhooksUpdateChan <- box.(*WebhooksUpdate)
	default:
		// if we land at this stage, the channel is either full or a unknown event has come through
		// empty the channel
		d.emptyChannel(evtName)
	}
}

func (d *evtDemultiplexer) emptyChannel(evtName string) {
	if !d.activateEventChannels {
		return
	}

	switch evtName {

	case EventChannelCreate:
		for range d.channelCreateChan {
		}
	case EventChannelDelete:
		for range d.channelDeleteChan {
		}
	case EventChannelPinsUpdate:
		for range d.channelPinsUpdateChan {
		}
	case EventChannelUpdate:
		for range d.channelUpdateChan {
		}
	case EventGuildBanAdd:
		for range d.guildBanAddChan {
		}
	case EventGuildBanRemove:
		for range d.guildBanRemoveChan {
		}
	case EventGuildCreate:
		for range d.guildCreateChan {
		}
	case EventGuildDelete:
		for range d.guildDeleteChan {
		}
	case EventGuildEmojisUpdate:
		for range d.guildEmojisUpdateChan {
		}
	case EventGuildIntegrationsUpdate:
		for range d.guildIntegrationsUpdateChan {
		}
	case EventGuildMemberAdd:
		for range d.guildMemberAddChan {
		}
	case EventGuildMemberRemove:
		for range d.guildMemberRemoveChan {
		}
	case EventGuildMemberUpdate:
		for range d.guildMemberUpdateChan {
		}
	case EventGuildMembersChunk:
		for range d.guildMembersChunkChan {
		}
	case EventGuildRoleCreate:
		for range d.guildRoleCreateChan {
		}
	case EventGuildRoleDelete:
		for range d.guildRoleDeleteChan {
		}
	case EventGuildRoleUpdate:
		for range d.guildRoleUpdateChan {
		}
	case EventGuildUpdate:
		for range d.guildUpdateChan {
		}
	case EventMessageCreate:
		for range d.messageCreateChan {
		}
	case EventMessageDelete:
		for range d.messageDeleteChan {
		}
	case EventMessageDeleteBulk:
		for range d.messageDeleteBulkChan {
		}
	case EventMessageReactionAdd:
		for range d.messageReactionAddChan {
		}
	case EventMessageReactionRemove:
		for range d.messageReactionRemoveChan {
		}
	case EventMessageReactionRemoveAll:
		for range d.messageReactionRemoveAllChan {
		}
	case EventMessageUpdate:
		for range d.messageUpdateChan {
		}
	case EventPresenceUpdate:
		for range d.presenceUpdateChan {
		}
	case EventPresencesReplace:
		for range d.presencesReplaceChan {
		}
	case EventReady:
		for range d.readyChan {
		}
	case EventResumed:
		for range d.resumedChan {
		}
	case EventTypingStart:
		for range d.typingStartChan {
		}
	case EventUserUpdate:
		for range d.userUpdateChan {
		}
	case EventVoiceServerUpdate:
		for range d.voiceServerUpdateChan {
		}
	case EventVoiceStateUpdate:
		for range d.voiceStateUpdateChan {
		}
	case EventWebhooksUpdate:
		for range d.webhooksUpdateChan {
		}
	}
}

func (d *evtDemultiplexer) triggerHandlers(ctx context.Context, evtName string, session Session, box interface{}) {
	d.RLock()
	handlers := d.handlers[evtName]
	d.RUnlock()

	dead := make([]*handlerSpec, 0)

	for i := range handlers {
		if alive := handlers[i].next(); !alive {
			dead = append(dead, handlers[i])
			continue
		}

		localEvt := handlers[i].runMdlws(box)
		if localEvt == nil {
			continue
		}

		handlers[i].dispatch(evtName, session, localEvt)
	}

	// time to remove the dead
	if len(dead) == 0 {
		return
	}

	d.Lock()

	// make sure the dead has not already been removed, after all this is concurrent
	handlers = d.handlers[evtName]
	for _, deadspec := range dead {
		for i, spec := range handlers {
			if spec == deadspec { // compare pointers
				// delete the dead spec, but keep the ordering
				copy(handlers[i:], handlers[i+1:])
				handlers[len(handlers)-1] = nil /// GC
				handlers = handlers[:len(handlers)-1]
				break
			}
		}
	}

	// update the specs
	d.handlers[evtName] = handlers
	d.Unlock()

	// notify specs
	go func(dead []*handlerSpec) {
		for i := range dead {
			if err := dead[i].ctrl.OnRemove(d.session); err != nil {
				d.session.Logger().Error(err)
			}
		}
	}(dead)
}

// ChannelCreate gives access to channelCreateChan for ChannelCreate events
func (d *evtDemultiplexer) ChannelCreate() <-chan *ChannelCreate {
	return d.channelCreateChan
}

// ChannelDelete gives access to channelDeleteChan for ChannelDelete events
func (d *evtDemultiplexer) ChannelDelete() <-chan *ChannelDelete {
	return d.channelDeleteChan
}

// ChannelPinsUpdate gives access to channelPinsUpdateChan for ChannelPinsUpdate events
func (d *evtDemultiplexer) ChannelPinsUpdate() <-chan *ChannelPinsUpdate {
	return d.channelPinsUpdateChan
}

// ChannelUpdate gives access to channelUpdateChan for ChannelUpdate events
func (d *evtDemultiplexer) ChannelUpdate() <-chan *ChannelUpdate {
	return d.channelUpdateChan
}

// GuildBanAdd gives access to guildBanAddChan for GuildBanAdd events
func (d *evtDemultiplexer) GuildBanAdd() <-chan *GuildBanAdd {
	return d.guildBanAddChan
}

// GuildBanRemove gives access to guildBanRemoveChan for GuildBanRemove events
func (d *evtDemultiplexer) GuildBanRemove() <-chan *GuildBanRemove {
	return d.guildBanRemoveChan
}

// GuildCreate gives access to guildCreateChan for GuildCreate events
func (d *evtDemultiplexer) GuildCreate() <-chan *GuildCreate {
	return d.guildCreateChan
}

// GuildDelete gives access to guildDeleteChan for GuildDelete events
func (d *evtDemultiplexer) GuildDelete() <-chan *GuildDelete {
	return d.guildDeleteChan
}

// GuildEmojisUpdate gives access to guildEmojisUpdateChan for GuildEmojisUpdate events
func (d *evtDemultiplexer) GuildEmojisUpdate() <-chan *GuildEmojisUpdate {
	return d.guildEmojisUpdateChan
}

// GuildIntegrationsUpdate gives access to guildIntegrationsUpdateChan for GuildIntegrationsUpdate events
func (d *evtDemultiplexer) GuildIntegrationsUpdate() <-chan *GuildIntegrationsUpdate {
	return d.guildIntegrationsUpdateChan
}

// GuildMemberAdd gives access to guildMemberAddChan for GuildMemberAdd events
func (d *evtDemultiplexer) GuildMemberAdd() <-chan *GuildMemberAdd {
	return d.guildMemberAddChan
}

// GuildMemberRemove gives access to guildMemberRemoveChan for GuildMemberRemove events
func (d *evtDemultiplexer) GuildMemberRemove() <-chan *GuildMemberRemove {
	return d.guildMemberRemoveChan
}

// GuildMemberUpdate gives access to guildMemberUpdateChan for GuildMemberUpdate events
func (d *evtDemultiplexer) GuildMemberUpdate() <-chan *GuildMemberUpdate {
	return d.guildMemberUpdateChan
}

// GuildMembersChunk gives access to guildMembersChunkChan for GuildMembersChunk events
func (d *evtDemultiplexer) GuildMembersChunk() <-chan *GuildMembersChunk {
	return d.guildMembersChunkChan
}

// GuildRoleCreate gives access to guildRoleCreateChan for GuildRoleCreate events
func (d *evtDemultiplexer) GuildRoleCreate() <-chan *GuildRoleCreate {
	return d.guildRoleCreateChan
}

// GuildRoleDelete gives access to guildRoleDeleteChan for GuildRoleDelete events
func (d *evtDemultiplexer) GuildRoleDelete() <-chan *GuildRoleDelete {
	return d.guildRoleDeleteChan
}

// GuildRoleUpdate gives access to guildRoleUpdateChan for GuildRoleUpdate events
func (d *evtDemultiplexer) GuildRoleUpdate() <-chan *GuildRoleUpdate {
	return d.guildRoleUpdateChan
}

// GuildUpdate gives access to guildUpdateChan for GuildUpdate events
func (d *evtDemultiplexer) GuildUpdate() <-chan *GuildUpdate {
	return d.guildUpdateChan
}

// MessageCreate gives access to messageCreateChan for MessageCreate events
func (d *evtDemultiplexer) MessageCreate() <-chan *MessageCreate {
	return d.messageCreateChan
}

// MessageDelete gives access to messageDeleteChan for MessageDelete events
func (d *evtDemultiplexer) MessageDelete() <-chan *MessageDelete {
	return d.messageDeleteChan
}

// MessageDeleteBulk gives access to messageDeleteBulkChan for MessageDeleteBulk events
func (d *evtDemultiplexer) MessageDeleteBulk() <-chan *MessageDeleteBulk {
	return d.messageDeleteBulkChan
}

// MessageReactionAdd gives access to messageReactionAddChan for MessageReactionAdd events
func (d *evtDemultiplexer) MessageReactionAdd() <-chan *MessageReactionAdd {
	return d.messageReactionAddChan
}

// MessageReactionRemove gives access to messageReactionRemoveChan for MessageReactionRemove events
func (d *evtDemultiplexer) MessageReactionRemove() <-chan *MessageReactionRemove {
	return d.messageReactionRemoveChan
}

// MessageReactionRemoveAll gives access to messageReactionRemoveAllChan for MessageReactionRemoveAll events
func (d *evtDemultiplexer) MessageReactionRemoveAll() <-chan *MessageReactionRemoveAll {
	return d.messageReactionRemoveAllChan
}

// MessageUpdate gives access to messageUpdateChan for MessageUpdate events
func (d *evtDemultiplexer) MessageUpdate() <-chan *MessageUpdate {
	return d.messageUpdateChan
}

// PresenceUpdate gives access to presenceUpdateChan for PresenceUpdate events
func (d *evtDemultiplexer) PresenceUpdate() <-chan *PresenceUpdate {
	return d.presenceUpdateChan
}

// PresencesReplace gives access to presencesReplaceChan for PresencesReplace events
func (d *evtDemultiplexer) PresencesReplace() <-chan *PresencesReplace {
	return d.presencesReplaceChan
}

// Ready gives access to readyChan for Ready events
func (d *evtDemultiplexer) Ready() <-chan *Ready {
	return d.readyChan
}

// Resumed gives access to resumedChan for Resumed events
func (d *evtDemultiplexer) Resumed() <-chan *Resumed {
	return d.resumedChan
}

// TypingStart gives access to typingStartChan for TypingStart events
func (d *evtDemultiplexer) TypingStart() <-chan *TypingStart {
	return d.typingStartChan
}

// UserUpdate gives access to userUpdateChan for UserUpdate events
func (d *evtDemultiplexer) UserUpdate() <-chan *UserUpdate {
	return d.userUpdateChan
}

// VoiceServerUpdate gives access to voiceServerUpdateChan for VoiceServerUpdate events
func (d *evtDemultiplexer) VoiceServerUpdate() <-chan *VoiceServerUpdate {
	return d.voiceServerUpdateChan
}

// VoiceStateUpdate gives access to voiceStateUpdateChan for VoiceStateUpdate events
func (d *evtDemultiplexer) VoiceStateUpdate() <-chan *VoiceStateUpdate {
	return d.voiceStateUpdateChan
}

// WebhooksUpdate gives access to webhooksUpdateChan for WebhooksUpdate events
func (d *evtDemultiplexer) WebhooksUpdate() <-chan *WebhooksUpdate {
	return d.webhooksUpdateChan
}
