package disgord

// Warning: This file has been automatically generated by generate/events/main.go
// Do NOT make changes here, instead adapt events.go and event/events.go and run go generate

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/andersfylling/disgord/websocket"
)

// NewDispatch construct a Dispatch object for reacting to web socket events
// from discord
func NewDispatch(activateEventChannels bool, evtChanSize int) *Dispatch {
	dispatcher := &Dispatch{
		activateEventChannels: activateEventChannels,

		listeners:      make(map[string][]interface{}),
		listenOnceOnly: make(map[string][]int),

		shutdown: make(chan struct{}),
	}

	if activateEventChannels {
        {{range .}} {{if .IsDiscordEvent}}
        dispatcher.{{.LowerCaseFirst}}Chan = make(chan *{{.}}, evtChanSize) {{end}} {{end}}
    }

	return dispatcher
}

// Dispatch holds all the channels and internal state for all registered
// observers
type Dispatch struct {
	{{range .}} {{if .IsDiscordEvent}}
	{{.LowerCaseFirst}}Chan chan *{{.}} {{end}} {{end}}

	activateEventChannels bool

	listeners      map[string][]interface{}
	listenOnceOnly map[string][]int

	shutdown chan struct{}

	listenersLock sync.RWMutex
}

// EventChan ... TODO
func (d *Dispatch) EventChan(event string) (channel interface{}, err error) {
	if !d.activateEventChannels {
	    return nil, errors.New("usage of event channels have not been activated. See disgord.Config")
	}

	switch event {
	{{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
			channel = d.{{.}}() {{end}} {{end}}
	default:
		err = errors.New("no event channel exists for given event: " + event)
	}

	return
}

func (d *Dispatch) triggerChan(ctx context.Context, evtName string, session Session, box interface{}) {
	if !d.activateEventChannels {
	    return
	}

	switch evtName {
	{{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
		d.{{.LowerCaseFirst}}Chan <- box.(*{{.}}) {{end}} {{end}}
	default:
		// if we land at this stage, the channel is either full or a unknown event has come through
		// empty the channel
		d.emptyChannel(evtName)
	}
}

func (d *Dispatch) emptyChannel(evtName string) {
	if !d.activateEventChannels {
	    return
	}

    switch evtName {
        {{range .}} {{if .IsDiscordEvent}}
        case Event{{.}}:
            for _ = range d.{{.LowerCaseFirst}}Chan {} {{end}} {{end}}
    }
}

func (d *Dispatch) triggerHandlers(ctx context.Context, evtName string, session Session, box interface{}) {
    d.listenersLock.RLock()
	switch evtName {
    {{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
		for _, listener := range d.listeners[Event{{.}}] {
		    if cb, ok := listener.({{.}}Handler); ok {
		        cb(session, box.(*{{.}}))
		    } else if cb, ok := listener.(SimpleHandler); ok {
		        cb(session)
		    } else if cb, ok := listener.(SimplestHandler); ok {
		        cb()
		    } else {
		        fmt.Println("ERROR! Incorrect handler type given for event: {{.}}")
		    }
		} {{end}} {{end}}
		//default:
		//	fmt.Printf("------\nTODO\nImplement handler for `%s`\n------\n\n", evtName)
	}
    d.listenersLock.RUnlock()

	// remove the run only once listeners
	d.listenersLock.Lock()
	defer d.listenersLock.Unlock()

	for _, index := range d.listenOnceOnly[evtName] {
		// https://github.com/golang/go/wiki/SliceTricks#delete-without-preserving-order
		d.listeners[evtName][index] = d.listeners[evtName][len(d.listeners[evtName])-1]
		d.listeners[evtName][len(d.listeners[evtName])-1] = nil
		d.listeners[evtName] = d.listeners[evtName][:len(d.listeners[evtName])-1]

		if len(d.listeners[evtName]) == 0 {
			// TODO: call removeEvent from socket pkg
		}
	}

	// remove the once only register
	if _, exists := d.listenOnceOnly[evtName]; exists {
		delete(d.listenOnceOnly, evtName)
	}
}

{{range .}} {{if .IsDiscordEvent}}
// {{.}} gives access to {{.LowerCaseFirst}}Chan for {{.}} events
func (d *Dispatch) {{.}}() <-chan *{{.}} {
	return d.{{.LowerCaseFirst}}Chan
} {{end}} {{end}}
