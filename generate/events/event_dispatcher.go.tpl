package disgord

// Warning: This file has been automatically generated by generate/events/main.go
// Do NOT make changes here, instead adapt events.go and event/events.go and run go generate

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/andersfylling/disgord/event"
)

// NewDispatch construct a Dispatch object for reacting to web socket events
// from discord
func NewDispatch(ws DiscordWebsocket) *Dispatch {
	dispatcher := &Dispatch{
		allChan: make(chan interface{}),
		{{range .}} {{if .IsDiscordEvent}}
		{{.LowerCaseFirst}}Chan: make(chan *{{.}}), {{end}} {{end}}

		ws: ws,

		listeners:      make(map[string][]interface{}),
		listenOnceOnly: make(map[string][]int),

		shutdown: make(chan struct{}),
	}

	return dispatcher
}

// Dispatch holds all the channels and internal state for all registered
// observers
type Dispatch struct {
	allChan chan interface{} // any event
	{{range .}} {{if .IsDiscordEvent}}
    {{.LowerCaseFirst}}Chan chan *{{.}} {{end}} {{end}}

	ws DiscordWebsocket

	listeners      map[string][]interface{}
	listenOnceOnly map[string][]int

	shutdown chan struct{}

	listenersLock sync.RWMutex
}

// EventChan ... TODO
func (d *Dispatch) EventChan(event string) (channel interface{}, err error) {
	switch event {
    {{range .}} {{if .IsDiscordEvent}}
    case Event{{.}}:
    		channel = d.{{.}}() {{end}} {{end}}
	default:
		err = errors.New("no event channel exists for given event: " + event)
	}

	return
}

// alwaysListenToChans makes sure no deadlocks occure
func (d *Dispatch) alwaysListenToChans() {
	go func() {
		stop := false
		for {
			select {
			case <-d.allChan:
			{{range .}} {{if .IsDiscordEvent}}
            case <-d.{{.LowerCaseFirst}}Chan: {{end}} {{end}}
			case <-d.shutdown:
				stop = true
			}

			if stop {
				break
			}
		}
	}()
}

func (d *Dispatch) triggerChan(ctx context.Context, evtName string, session Session, box interface{}) {
	prepareBox(evtName, box)

	switch evtName {
	{{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
		d.{{.LowerCaseFirst}}Chan <- box.(*{{.}}) {{end}} {{end}}
	default:
		fmt.Printf("------\nTODO\nImplement channel for `%s`\n------\n\n", evtName)
	}
}

func (d *Dispatch) triggerCallbacks(ctx context.Context, evtName string, session Session, box interface{}) {
	switch evtName {
    {{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
		for _, listener := range d.listeners[Event{{.}}] {
			(listener.({{.}}Callback))(session, box.(*{{.}}))
		} {{end}} {{end}}
		//default:
		//	fmt.Printf("------\nTODO\nImplement callback for `%s`\n------\n\n", evtName)
	}

	// remove the run only once listeners
	d.listenersLock.Lock()
	defer d.listenersLock.Unlock()

	for _, index := range d.listenOnceOnly[evtName] {
		// https://github.com/golang/go/wiki/SliceTricks#delete-without-preserving-order
		d.listeners[evtName][index] = d.listeners[evtName][len(d.listeners[evtName])-1]
		d.listeners[evtName][len(d.listeners[evtName])-1] = nil
		d.listeners[evtName] = d.listeners[evtName][:len(d.listeners[evtName])-1]

		if len(d.listeners[evtName]) == 0 {
			// TODO: call removeEvent from socket pkg
		}
	}

	// remove the once only register
	if _, exists := d.listenOnceOnly[evtName]; exists {
		delete(d.listenOnceOnly, evtName)
	}
}

{{range .}} {{if .IsDiscordEvent}}
// {{.}} gives access to {{.LowerCaseFirst}}Chan for {{.}} events
func (d *Dispatch) {{.}}() <-chan *{{.}} {
	d.ws.RegisterEvent(event.{{.}})
	return d.{{.LowerCaseFirst}}Chan
} {{end}} {{end}}
