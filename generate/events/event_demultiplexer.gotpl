package disgord

// Warning: This file has been automatically generated by generate/events/main.go
// DO NOT EDIT! This file is overwritten at "go generate", instead adapt events.go
// and event/events.go and run go generate

import (
	"context"
	"errors"
	"fmt"
	"sync"
)

// HandlerCtrl used when inserting a handler to dictate whether or not the handler(s) should
// still be kept in the handlers list..
type HandlerCtrl interface {
	OnInsert(Session) error
	OnRemove(Session) error

	// IsDead does not need to be locked as the demultiplexer access it synchronously.
	IsDead() bool

	// Update For every time Update is called, it's internal trackers must be updated.
	// you should assume that .Update() means the handler was used.
	Update()
}

type eternalHandlersCtrl struct {
    Ctrl
}
var _ HandlerCtrl = (*eternalHandlersCtrl)(nil)

func (c *eternalHandlersCtrl) Update() {}
func (c *eternalHandlersCtrl) IsDead() bool { return false; }

// reused by handlers that have no ctrl defined
var eternalCtrl = &eternalHandlersCtrl{}

type Handler = interface{}
type Middleware = func(interface{}) interface{}

// handlerSpec (handler specification) holds the details for executing the handler
type handlerSpec struct {
    sync.RWMutex
	middlewares []Middleware
	handlers    []Handler
    ctrl        HandlerCtrl
}

func (hs *handlerSpec) next() bool {
    hs.Lock()
    defer hs.Unlock()

    if hs.ctrl.IsDead() {
        return false
    }

    hs.ctrl.Update()
    return true
}

func (hs *handlerSpec) populate(inputs ...interface{}) (err error) {
	var i int

	// middlewares
	for ; i < len(inputs); i++ {
		if mdlw, ok := inputs[i].(Middleware); ok {
			hs.middlewares = append(hs.middlewares, mdlw)
		} else {
			break
		}
	}

	// handlers
	for ; i < len(inputs) - 1; i++ {
		if handler, ok := inputs[i].(Handler); ok {
			hs.handlers = append(hs.handlers, handler)
		} else {
			break
		}
	}

	// check if last arg is a controller
	if i < len(inputs) {
		if ctrl, ok := inputs[i].(HandlerCtrl); ok {
			hs.ctrl = ctrl
			i++
		} else if handler, ok := inputs[i].(Handler); ok {
			hs.handlers = append(hs.handlers, handler)
			hs.ctrl = eternalCtrl
			i++
		}
	}

	if len(inputs) != i {
	    format := "unable to add all handlers/middlewares (%d/%d). Are they in correct order? middlewares, then handlers"
	    err = errors.New(fmt.Sprintf(format, i, len(inputs)))
	}

	return err
}

func (hs *handlerSpec) runMdlws(evt interface{}) interface{} {
	for i := range hs.middlewares {
		evt = hs.middlewares[i](evt) // note how the evt pointer is overwritten
		if evt == nil {
			break
		}
	}

	return evt
}

func (hs *handlerSpec) dispatch(evtName string, session Session, evt interface{}) {
	// ordering is important
	switch evtName {
    {{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
		for _, handler := range hs.handlers {
		    if cb, ok := handler.({{.}}Handler); ok {
		        cb(session, evt.(*{{.}}))
		    } else if cb, ok := handler.(SimpleHandler); ok {
		        cb(session)
		    } else if cb, ok := handler.(SimplestHandler); ok {
		        cb()
		    } else {
		        fmt.Println("ERROR! Incorrect handler type given for event: {{.}}")
		    }
		} {{end}} {{end}}
	}
}

// NewDispatch construct a Dispatch object for reacting to web socket events
// from discord
func newEvtDemultiplexer(activateEventChannels bool, evtChanSize int) *evtDemultiplexer {
	dem := &evtDemultiplexer{
		activateEventChannels: activateEventChannels,
		handlers: make(map[string][]*handlerSpec),
		shutdown: make(chan struct{}),
	}

	if activateEventChannels {
        {{range .}} {{if .IsDiscordEvent}}
        dem.{{.LowerCaseFirst}}Chan = make(chan *{{.}}, evtChanSize) {{end}} {{end}}
    }

	return dem
}

// evtDemultiplexer holds all the channels and internal state for all registered
// observers
type evtDemultiplexer struct {
	sync.RWMutex

	{{range .}} {{if .IsDiscordEvent}}
	{{.LowerCaseFirst}}Chan chan *{{.}} {{end}} {{end}}

	activateEventChannels bool

	handlers map[string][]*handlerSpec

    // use session to allow mocking the client instance later on
    session Session
	shutdown chan struct{}
}

// EventChan ... TODO
func (d *evtDemultiplexer) EventChan(evt string) (channel interface{}, err error) {
	if !d.activateEventChannels {
	    return nil, errors.New("usage of event channels have not been activated. See disgord.Config")
	}

	switch evt {
	{{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
			channel = d.{{.}}() {{end}} {{end}}
	default:
		err = errors.New("no event channel exists for given event: " + evt)
	}

	return
}

func (d *evtDemultiplexer) triggerChan(ctx context.Context, evtName string, session Session, box interface{}) {
	if !d.activateEventChannels {
	    return
	}

	switch evtName {
	{{range .}} {{if .IsDiscordEvent}}
	case Event{{.}}:
		d.{{.LowerCaseFirst}}Chan <- box.(*{{.}}) {{end}} {{end}}
	default:
		// if we land at this stage, the channel is either full or a unknown event has come through
		// empty the channel
		d.emptyChannel(evtName)
	}
}

func (d *evtDemultiplexer) emptyChannel(evtName string) {
	if !d.activateEventChannels {
	    return
	}

    switch evtName {
        {{range .}} {{if .IsDiscordEvent}}
        case Event{{.}}:
            for range d.{{.LowerCaseFirst}}Chan {} {{end}} {{end}}
    }
}

func (d *evtDemultiplexer) triggerHandlers(ctx context.Context, evtName string, session Session, box interface{}) {
	d.RLock()
	handlers := d.handlers[evtName]
	d.RUnlock()

	dead := make([]*handlerSpec, 0)

	for i := range handlers {
		if alive := handlers[i].next(); !alive {
			dead = append(dead, handlers[i])
			continue
		}

		localEvt := handlers[i].runMdlws(box)
		if localEvt == nil {
			continue
		}

		handlers[i].dispatch(evtName, session, localEvt)
	}

	// time to remove the dead
	if len(dead) == 0 {
		return
	}

	d.Lock()

	// make sure the dead has not already been removed, after all this is concurrent
	handlers = d.handlers[evtName]
	for _, deadspec := range dead {
		for i, spec := range handlers {
			if spec == deadspec { // compare pointers
				// delete the dead spec, but keep the ordering
				copy(handlers[i:], handlers[i+1:])
				handlers[len(handlers)-1] = nil /// GC
				handlers = handlers[:len(handlers)-1]
				break
			}
		}
	}

	// update the specs
	d.handlers[evtName] = handlers
	d.Unlock()

	// notify specs
	go func(dead []*handlerSpec) {
	    for i := range dead {
			if err := dead[i].ctrl.OnRemove(d.session); err != nil {
				d.session.Logger().Error(err)
			}
	    }
	}(dead)
}

{{range .}} {{if .IsDiscordEvent}}
// {{.}} gives access to {{.LowerCaseFirst}}Chan for {{.}} events
func (d *evtDemultiplexer) {{.}}() <-chan *{{.}} {
	return d.{{.LowerCaseFirst}}Chan
} {{end}} {{end}}
